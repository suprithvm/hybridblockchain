package blockchain

import (
	"blockchain-core/blockchain/gas"
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"encoding/gob"
	"encoding/hex"
	"fmt"
	"time"
)

// Add these constants
const (
	DefaultGasPrice = 1000  // Base price for normal transactions
	DefaultGasLimit = 21000 // Base gas for simple transfers
	MaxTotalFee     = 2.0   // Maximum total fee in native tokens
)

// Transaction represents a blockchain transaction
type Transaction struct {
	TransactionID string  // Unique ID for the transaction
	Sender        string  // Address of the sender
	Receiver      string  // Address of the receiver
	Amount        float64 // Transaction amount
	Timestamp     int64   // Time of creation
	Signature     string  // Digital signature for verification
	GasFee        float64 // Gas fee for prioritization (added later)
	Inputs        []UTXO  // Inputs referencing previous UTXOs
	Outputs       []UTXO  // Outputs generated by this transaction

	// Gas-related fields
	GasLimit     uint64 // Maximum gas willing to use
	GasPrice     uint64 // Price per unit of gas
	GasUsed      uint64 // Actual gas used (set after execution)
	Priority     int    // Transaction priority level
	MaxFeePerGas uint64 `json:"max_fee_per_gas"`
}

// TransactionInput references a UTXO being spent
type TransactionInput struct {
	TransactionID string
	OutputIndex   int
	Signature     string
}

// TransactionOutput defines a new UTXO created by a transaction
type TransactionOutput struct {
	Receiver string
	Amount   float64
}

// MultiSigTransaction represents a transaction requiring multiple signatures
type MultiSigTransaction struct {
	Transaction
	Signatures map[string]string // Address -> Signature
}

func NewTransaction(sender, receiver string, amount float64, gasPrice uint64, gasLimit uint64) (*Transaction, error) {
	// Create transaction with gas parameters
	tx := &Transaction{
		TransactionID: "", // Will be set after initialization
		Sender:        sender,
		Receiver:      receiver,
		Amount:        amount,
		Timestamp:     time.Now().Unix(),
		GasLimit:      gasLimit,
		GasPrice:      gasPrice,
		MaxFeePerGas:  gasPrice * 2, // Set max fee to 2x the base gas price
		Priority:      gas.PriorityNormal,
	}

	// Set the transaction ID
	tx.TransactionID = tx.GenerateTransactionID()

	// Calculate total gas fee with proper type conversion
	tx.GasFee = float64(tx.GasLimit * tx.GasPrice)

	// Validate gas parameters
	if err := tx.ValidateGas(); err != nil {
		return nil, fmt.Errorf("invalid gas parameters: %w", err)
	}

	return tx, nil
}

// GenerateTransactionID generates a unique ID for the transaction
func (tx *Transaction) GenerateTransactionID() string {
	data := fmt.Sprintf("%s%s%f%d%d%d%d",
		tx.Sender,
		tx.Receiver,
		tx.Amount,
		tx.GasPrice,
		tx.GasLimit,
		tx.Priority,
		tx.Timestamp,
	)
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

// Hash computes the hash of the transaction data.
func (tx *Transaction) Hash() string {
	data := fmt.Sprintf("%s%s%f%d", tx.Sender, tx.Receiver, tx.Amount, tx.Timestamp)
	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])
}

// SerializeTransaction serializes a transaction
func SerializeTransaction(tx *Transaction) ([]byte, error) {
	var buffer bytes.Buffer
	encoder := gob.NewEncoder(&buffer)
	err := encoder.Encode(tx)
	if err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}

// DeserializeTransaction deserializes a transaction
func DeserializeTransaction(data []byte) (*Transaction, error) {
	var tx Transaction
	decoder := gob.NewDecoder(bytes.NewReader(data))
	err := decoder.Decode(&tx)
	if err != nil {
		return nil, err
	}
	return &tx, nil
}

// Equals compares two transactions for deep equality
func (tx *Transaction) Equals(other *Transaction) bool {
	if tx.TransactionID != other.TransactionID ||
		tx.Sender != other.Sender ||
		tx.Receiver != other.Receiver ||
		tx.Amount != other.Amount ||
		tx.Timestamp != other.Timestamp ||
		tx.GasFee != other.GasFee ||
		tx.Signature != other.Signature {
		return false
	}

	// Compare Inputs
	if len(tx.Inputs) != len(other.Inputs) {
		return false
	}
	for i, input := range tx.Inputs {
		if input != other.Inputs[i] {
			return false
		}
	}

	// Compare Outputs
	if len(tx.Outputs) != len(other.Outputs) {
		return false
	}
	for i, output := range tx.Outputs {
		if output != other.Outputs[i] {
			return false
		}
	}

	return true
}

// AddSignature adds a signature to the transaction
func (tx *MultiSigTransaction) AddSignature(address, signature string) error {
	if _, exists := tx.Signatures[address]; exists {
		return fmt.Errorf("signature from %s already exists", address)
	}
	tx.Signatures[address] = signature
	return nil
}

// ValidateSignatures validates a single-signature transaction.
func (tx *Transaction) ValidateSignatures(wallet interface{}, publicKeyMap map[string]*ecdsa.PublicKey) bool {
	if wallet, ok := wallet.(*Wallet); ok {
		return VerifySignature(wallet.PublicKey, tx.Hash(), tx.Signature)
	}
	return false
}

// Hash computes the hash for a multi-signature transaction.
func (tx *MultiSigTransaction) Hash() string {
	return tx.Transaction.Hash()
}

// ValidateSignatures validates a multi-signature transaction.
func (tx *MultiSigTransaction) ValidateSignatures(wallet interface{}, publicKeyMap map[string]*ecdsa.PublicKey) bool {
	multiSigWallet, ok := wallet.(*MultiSigwWallet)
	if !ok {
		return false
	}

	validSigs := 0
	for owner, signature := range tx.Signatures {
		publicKey, exists := publicKeyMap[owner]
		if !exists || publicKey == nil {
			continue
		}
		if VerifySignature(publicKey, tx.Hash(), signature) {
			validSigs++
		}
	}
	return validSigs >= multiSigWallet.RequiredSigs
}

// SignTransaction signs a transaction using the private key
func SignTransaction(tx *Transaction, privateKey *ecdsa.PrivateKey) (string, error) {
	// Get the transaction hash
	txHash := tx.Hash()

	// Use the existing SignMessage function
	signature, err := SignMessage(privateKey, txHash)
	if err != nil {
		return "", fmt.Errorf("failed to sign transaction: %v", err)
	}

	return signature, nil
}

// Add helper method
func (tx *Transaction) CalculateFee() uint64 {
	return tx.GasPrice * tx.GasUsed
}

// Add method to validate gas parameters
func (tx *Transaction) ValidateGas() error {
	// Check gas limit bounds
	if tx.GasLimit < gas.BaseTxGas || tx.GasLimit > (gas.BaseTxGas*100) {
		return fmt.Errorf("gas limit %d outside allowed range [%d, %d]",
			tx.GasLimit, gas.BaseTxGas, gas.BaseTxGas*100)
	}

	// Check gas price minimum
	if tx.GasPrice < gas.MinGasPrice {
		return fmt.Errorf("gas price %d below minimum %d",
			tx.GasPrice, gas.MinGasPrice)
	}

	// Calculate total fee with proper type conversion
	totalFee := float64(tx.GasLimit*tx.GasPrice) / 1e18 // Convert to native tokens
	if totalFee > MaxTotalFee {
		return fmt.Errorf("total fee %.2f tokens exceeds maximum %.2f tokens",
			totalFee, MaxTotalFee)
	}

	return nil
}

// GetData returns the transaction data for gas calculation
func (tx *Transaction) GetData() []byte {
	// Combine relevant transaction fields into a byte slice
	data := fmt.Sprintf("%s%s%f%d%d",
		tx.Sender,
		tx.Receiver,
		tx.Amount,
		tx.GasPrice,
		tx.GasLimit,
	)
	return []byte(data)
}
